"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var RemoteDocService_1 = require("../remote-doc/RemoteDocService");
module.exports = function (PersistObjectTemplate) {
    var Promise = require('bluebird');
    var _ = require('underscore');
    /**
     * Save the object to persistent storage
     *
     * A copy of the object is made which has only the persistent properties
     * and all objects references for objects not stored in the the document
     * replaced by foreign keys.  Arrays of objects not stored in the document
     * are adjusted such that their foreign keys point back to this object.
     * Any related objects stored in other documents are also saved.
     *
     * @param {object} obj  Only required parameter - the object to be saved
     * @param {object} txn transaction object -- can be used only in the end trasaction callback.
     * @param {object} logger object template logger
     * @returns {*}
     */
    PersistObjectTemplate.persistSaveKnex = function (obj, txn, logger) {
        return __awaiter(this, void 0, void 0, function () {
            function log(defineProperty, pojo, prop) {
                if (defineProperty.logChanges)
                    dataSaved[prop] = pojo[prop];
            }
            function copyProps(obj) {
                var newObj = {};
                for (var prop in obj)
                    newObj[prop] = obj[prop];
                return newObj;
            }
            function updatePersistorProp(obj, prop, values) {
                if (!obj[prop])
                    obj[prop] = {};
                var modified = false;
                _.map(values, function (value, key) {
                    if (obj[prop][key] != value) {
                        obj[prop][key] = value;
                        modified = true;
                    }
                });
                if (modified)
                    obj[prop] = copyProps(obj[prop]);
            }
            var remoteDocService, template, schema, templateName, isDocumentUpdate, props, promises, dataSaved, remoteUpdateFns, pojo, _loop_1, this_1, defineProperty, value, childForeignKey, foreignFilterKey, foreignFilterValue, foreignKey, prop;
            return __generator(this, function (_a) {
                (logger || this.logger).debug({ component: 'persistor', module: 'db.persistSaveKnex', activity: 'pre', data: { template: obj.__template__.__name__, id: obj.__id__, _id: obj._id } });
                this.checkObject(obj);
                remoteDocService = null;
                template = obj.__template__;
                schema = template.__schema__;
                templateName = template.__name__;
                isDocumentUpdate = obj.__version__ ? true : false;
                props = template.getProperties();
                promises = [];
                dataSaved = {};
                remoteUpdateFns = [];
                obj._id = obj._id || this.createPrimaryKey(obj);
                pojo = { _template: obj.__template__.__name__, _id: obj._id };
                _loop_1 = function () {
                    defineProperty = props[prop];
                    value = obj[prop];
                    // Deal with properties we don't plan to save
                    if (!this_1._persistProperty(defineProperty) || !defineProperty.enumerable || typeof (value) == 'undefined' || value == null) {
                        // Make sure we don't wipe out foreign keys of non-cascaded object references
                        if (defineProperty.type != Array &&
                            defineProperty.type && defineProperty.type.isObjectTemplate &&
                            obj[prop + 'Persistor'] && !obj[prop + 'Persistor'].isFetched && obj[prop + 'Persistor'].id &&
                            !(!schema || !schema.parents || !schema.parents[prop] || !schema.parents[prop].id)) {
                            pojo[schema.parents[prop].id] = obj[prop + 'Persistor'].id;
                            return "continue";
                        }
                        if (!this_1._persistProperty(defineProperty) || !defineProperty.enumerable || typeof (value) == 'undefined')
                            return "continue";
                    }
                    // Handle Arrays
                    if (defineProperty.type == Array && defineProperty.of.isObjectTemplate) {
                        // Arrays of Pojos just get saved
                        if (!defineProperty.of.__table__) {
                            pojo[prop] = value;
                            // Templated arrays we need to make sure their foreign keys are up-to-date
                        }
                        else if (value instanceof Array) {
                            if (!schema.children[prop])
                                throw new Error('Missing children entry for ' + prop + ' in ' + templateName);
                            childForeignKey = schema.children[prop].id;
                            if (schema.children[prop].filter && (!schema.children[prop].filter.value || !schema.children[prop].filter.property))
                                throw new Error('Incorrect filter properties on ' + prop + ' in ' + templateName);
                            foreignFilterKey = schema.children[prop].filter ? schema.children[prop].filter.property : null;
                            foreignFilterValue = schema.children[prop].filter ? schema.children[prop].filter.value : null;
                            value.forEach(function (referencedObj, ix) {
                                if (!referencedObj) {
                                    (logger || this.logger).debug({ component: 'persistor', module: 'db.persistSaveKnex' }, obj.__id__ + '.' + prop + '[' + ix + '] is null');
                                    return;
                                }
                                if (!defineProperty.of.__schema__.parents)
                                    throw new Error('Missing parent entry in ' + defineProperty.of.__name__ + ' for ' + templateName);
                                // Go through each of the parents in the schema to find the one matching this reference
                                _.each(defineProperty.of.__schema__.parents, function (parentSchemaEntry, parentProp) {
                                    if (parentSchemaEntry.id == childForeignKey) {
                                        // If anything is missing in the child such as the persistor property not having been
                                        // setup or the filter property not being setup, fill in and set it dirty
                                        if (!referencedObj[parentProp + 'Persistor'] || !referencedObj[parentProp + 'Persistor'].id ||
                                            referencedObj[parentProp + 'Persistor'].id != obj._id ||
                                            (foreignFilterKey ? referencedObj[foreignFilterKey] != foreignFilterValue : false)) {
                                            // Take care of filter property
                                            if (foreignFilterKey)
                                                referencedObj[foreignFilterKey] = foreignFilterValue;
                                            // Force parent pointer
                                            if (referencedObj[parentProp] != obj)
                                                referencedObj[parentProp] = obj;
                                            referencedObj.setDirty(txn);
                                        }
                                    }
                                });
                                if (!referencedObj._id)
                                    referencedObj._id = this.createPrimaryKey(referencedObj);
                            }.bind(this_1));
                            if (schema.children[prop].pruneOrphans && obj[prop + 'Persistor'].isFetched)
                                promises.push(this_1.knexPruneOrphans(obj, prop, txn, foreignFilterKey, foreignFilterValue, logger));
                        }
                        updatePersistorProp(obj, prop + 'Persistor', { isFetching: false, isFetched: true });
                        // One-to-One
                    }
                    else if (defineProperty.type && defineProperty.type.isObjectTemplate) {
                        // Make sure schema is in order
                        if (!schema || !schema.parents || !schema.parents[prop] || !schema.parents[prop].id)
                            throw new Error(obj.__template__.__name__ + '.' + prop + ' is missing a parents schema entry');
                        foreignKey = (schema.parents && schema.parents[prop]) ? schema.parents[prop].id : prop;
                        var isChanged = value && (!value._id || !value.__version__);
                        if (value && !value._id) {
                            value._id = this_1.createPrimaryKey(value);
                        }
                        if (isChanged) {
                            value.setDirty(txn);
                        }
                        pojo[foreignKey] = value ? value._id : null;
                        updatePersistorProp(obj, prop + 'Persistor', { isFetching: false, id: value ? value._id : null, isFetched: true });
                        dataSaved[foreignKey] = pojo[foreignKey] || 'null';
                    }
                    else if (defineProperty.isRemoteObject && defineProperty.isRemoteObject === true) {
                        var uniqueIdentifier = obj._id;
                        var remoteObject = obj[prop];
                        if (remoteObject && defineProperty.remoteKeyBase) {
                            remoteDocService = RemoteDocService_1.RemoteDocService.new(this_1.environment, this_1.remoteDocHostURL);
                            // the contents of the object we want to save in the remote store
                            var documentBody_1 = remoteObject;
                            // unique identifier to find the object we're saving in the remote store
                            var objectKey_1 = defineProperty.remoteKeyBase + "-" + uniqueIdentifier;
                            var bucket_1 = this_1.bucketName;
                            try {
                                // push function to upload the document to remote store
                                remoteUpdateFns.push(function () { return remoteDocService.uploadDocument(documentBody_1, objectKey_1, bucket_1); });
                                // only place a reference to the remote object in the database itself - not the actual
                                // contents of the property.
                                pojo[prop] = objectKey_1;
                                defineProperty.__remoteObjectKey__ = objectKey_1;
                                log(defineProperty, pojo, prop);
                            }
                            catch (e) {
                                (logger || this_1.logger).error({
                                    component: 'persistor',
                                    module: 'update',
                                    activity: 'persistSaveKnex',
                                    data: {
                                        template: obj.__template__.__name__,
                                        errorMessage: e,
                                        message: 'there was a problem uploading the document'
                                    }
                                });
                                throw e;
                            }
                        }
                        else if (remoteObject && !defineProperty.remoteKeyBase) {
                            throw new Error('RemoteObject missing unique identifier key for storage in decorator');
                        }
                    }
                    else if (defineProperty.type == Array || defineProperty.type == Object) {
                        pojo[prop] = (obj[prop] === null || obj[prop] === undefined) ? null : JSON.stringify(obj[prop]);
                        log(defineProperty, pojo, prop);
                    }
                    else if (defineProperty.type == Date) {
                        pojo[prop] = obj[prop] ? obj[prop] : null;
                        log(defineProperty, pojo, prop);
                    }
                    else if (defineProperty.type == Boolean) {
                        pojo[prop] = obj[prop] == null ? null : (obj[prop] ? true : false);
                        log(defineProperty, pojo, prop);
                    }
                    else {
                        pojo[prop] = obj[prop];
                        log(defineProperty, pojo, prop);
                    }
                };
                this_1 = this;
                /**
                 *  Walk through all the properties and copy them to POJO with special treatment for
                 *  references to templated objects where we have to maintain foreign key relationships
                 */
                for (prop in props) {
                    _loop_1();
                }
                (logger || this.logger).debug({ component: 'persistor', module: 'db', activity: 'dataLogging', data: { template: obj.__template__.__name__, _id: pojo._id, values: dataSaved } });
                promises.push(this.saveKnexPojo(obj, pojo, isDocumentUpdate ? obj._id : null, txn, logger));
                return [2 /*return*/, Promise.all(promises) // update sql saves first
                        .then(function () { return (Promise.all(remoteUpdateFns.map(
                    // We want to wait to execute remote updates until the sql has resolved
                    function (remoteUpdateFn) { return remoteUpdateFn(); })).then(function (updateData) {
                        if (txn) {
                            txn.remoteObjects = txn.remoteObjects || new Map();
                            for (var _i = 0, updateData_1 = updateData; _i < updateData_1.length; _i++) {
                                var update = updateData_1[_i];
                                txn.remoteObjects.set(update.key, update.versionId);
                            }
                        }
                    })); }) // update remote objects second
                        .then(function () {
                        return obj;
                    })];
            });
        });
    };
};
